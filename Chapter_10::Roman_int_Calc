#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <cctype>
#include <algorithm>
//===============================================================================================================================
										//	CLASS Roman_int
//===============================================================================================================================
class Roman_int
{
public:
	friend std::istream &operator>>(std::istream &is, Roman_int &r)
	{
		char ch, next;
		int ch_to_int, res = 0;
		bool riverse = false;

		while (is >> ch)
		{
			ch_to_int = r.roman_switch(ch);

			next = std::cin.peek();

			if (!(isalpha(next)))
			{
				r.romint = res + ch_to_int;
				break;
			}

			int next_to_int = r.roman_switch(next);

			if (next_to_int <= ch_to_int)
			{
				if (riverse == true)
					res += next_to_int;

				else
					res += ch_to_int;
			}

			if (next_to_int > ch_to_int)
			{
				res += next_to_int - ch_to_int;
				riverse = true;
			}

			if (next == '\n')
			{
				r.romint = res;
				break;
			}
		}
		return is;
	}
	int roman_switch(char &sbl);
	//int convert_roman_to_int(std::string &rom);

	int get_rom()
	{
		return romint;
	}

	friend std::ostream &operator<<(std::ostream &os, Roman_int &r)
	{
		return os << r.romint << '\n';
	}

private:
	int romint = 0;
};
//===============================================================================================================================
Roman_int r;
//===================================================================================================================
int Roman_int::roman_switch(char &sbl)
{
	switch (sbl)
	{
		case 'I': return 1;
		case 'V': return 5;
		case 'X': return 10;
		case 'L': return 50;
		case 'C': return 100;
		case 'D': return 500;
		case 'M': return 1000;

		default:
			return 0;
	}
}
//===============================================================================================================================
std::string roman_switch_lil(int &sbl)
{
	switch (sbl)
	{
		case 1: return "I";
		case 2: return "II";
		case 3: return "III";
		case 4: return "IV";
		case 5: return "V";
		case 6: return "VI";
		case 7: return "VII";
		case 8: return "VIII";
		case 9:	return "IX";
		case 10: return "X";
		case 20: return "XX";
		case 30: return "XXX";
		case 40: return "XL";
		case 50: return "L";
		case 60: return "LX";
		case 70: return "LXX";
		case 80: return "LXXX";
		case 90: return "XC";
		case 100: return "C";
		case 200: return "CC";
		case 300: return "CCC";
		case 400: return "CD";
		case 500: return "D";
		case 600: return "DC";
		case 700: return "DCC";
		case 800: return "DCCC";
		case 900: return "CM";
		case 1000: return "M";
		case 2000: return "MM";
		case 3000: return "MMM";

		default:
			break;
	}
}
////===============================================================================================================================
//int Roman_int::convert_roman_to_int(std::string &rom)
//{
//	std::vector<int> romit;
//	int result = 0;
//
//	for (int i = 0; i < rom.size(); i++)
//	{
//		int rim = r.roman_switch(rom[i]);
//		romit.push_back(rim);
//	}
//
//	for (int i = 0; i < romit.size(); i++)
//	{
//		if (romit[i + 1] == '\n')
//		{
//			result += romit[i];
//			break;
//		}
//		if (romit[i] < romit[i + 1])
//		{
//			result += romit[i + 1] - romit[i];
//		}
//		
//		if (romit[i] >= romit[i + 1])
//		{
//			result += romit[i] + romit[i + 1];
//		}
//	}
//
//	return result;
//}
//===============================================================================================================================
std::string convert_int_to_string(int &doub)
{
	std::vector<int> romins;
	std::string otv;

	while (doub > 0)
	{
		romins.push_back(doub % 10);
			doub /= 10;
	}
	std::reverse(romins.begin(), romins.end());

	// Получили 3 7 1 3

	if (romins.size() == 4)
	{
		
		int let = romins[0] * 1000;
		otv += roman_switch_lil(let);
		int tet = romins[1] * 100;
		otv += roman_switch_lil(tet);
		int met = romins[2] * 10;
		otv += roman_switch_lil(met);
		otv += roman_switch_lil(romins[3]);
	}

	if (romins.size() == 3)
	{
		int let = romins[0] * 100;
		otv += roman_switch_lil(let);
		int tet = romins[1] * 10;
		otv += roman_switch_lil(tet);

		if (romins[2] == 0)
			return otv;

		int get = romins[2];
		otv += roman_switch_lil(get);
	}

	if (romins.size() == 2)
	{
		int let = romins[0] * 10;
		otv += roman_switch_lil(let);
		otv += roman_switch_lil(romins[1]);
	}

	if (romins.size() == 1)
	{
		otv += roman_switch_lil(romins[0]);
	}

	return otv;
}
//===============================================================================================================================
void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================
int expression();
int term();
int factorial(int left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	int value;
	std::string name;

	Token(char ch)
		:kind(ch), value(0.0)
	{
	}

	Token(char ch, int val)
		:kind(ch), value(val)
	{
	}

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{
	}
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	std::string statement();
	//	int declaration();
	void calculate();
	bool is_declared(std::string var);
	int define_name(std::string var, int val);

private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{ '\0' } // В буфере нет ни одного объекта
{
}
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const char let = 'l';	// Лексема let
const std::string declkey = "let";	// Ключевое слово let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char number = '8';
const char quit = 'q';
const char print = ';';
const char romans = 'R';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
		case ';': case 'q': case '(': case ')': case '{': case '}': case 'sqrt':
		case '+': case '-': case '*': case '/': case '!': case '%': case '=':

			return Token(ch);

		case 'I': case 'V': case 'X': case 'L': case 'C': case 'D': case 'M':
		{
			std::cin.putback(ch);
			std::cin >> r;
			
			int val = r.get_rom();

				// convert_roman_to_int(rom);

			return Token(number, val);
		}

		case '.':
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':


		{
			/*
			ЗДЕСЬ ПЕРЕВОДИТЬ РИМСКИЕ ЦИФРЫ В АРАБСКИЕ ДЛЯ ВЕДЕНИЯ ПОДСЧЕТА
			*/


			std::cin.putback(ch); // возвращем цифру обратно в поток ввода

			int val;
			std::cin >> val; // считываем число с плавающей точкой
			return Token(number, val); // пусть символ '8' означает "число"
		}
		default:

			if (isalpha(ch))	// Является ли лексема введная буквой?
			{
				std::string s;
				s += ch;

				while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)))	// Считываем все следующие буквы
					s += ch;

				std::cin.putback(ch);

				// Проверяем какие буквы в нашей строке s
				// При совпадение со строками присваиваем значение символьное для использование в switch

				if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

				else if (s == declkey) return Token(let);	// Ключевое слово let
				return Token(name, s);

			}
			error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
		if (ch == c) return;
}
//===============================================================================================================================
int get_value(std::string s);
//===============================================================================================================================
int primary()
{
	Token t = ts.get();

	int value;

	if (t.kind == number)
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!')
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
		case uSqrt:
		{
			t = ts.get();	// Получаем следующий элемент

			if (t.kind != '(')	// Является ли элемент после sqrt - '('
				error("sqrt it`s looks like sqrt(x)");

			int d = expression();	// Если является считаем внутри скобок уравнение

			if (d <= 0) error("sqrt cannot be negative");
			t = ts.get();	// Берем символ после уравнения

			if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
				error("please, don`t forget == ( ***** )");

			return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
		}

		case '(':
		{
			int d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			int d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

		default:
			error("Primary Exprected!");
	}
}
//===============================================================================================================================
int factorial(int value)
{
	int i;
	int fact = 1;

	if (value < 0) error("Factorial not may < 0");

	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;

	return value;
}
//===============================================================================================================================
int term()
{
	int left = primary();

	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {

			case '*':
			{
				left *= primary();
				break;
			}

			case '/':
			{
				int d = primary();
				if (d == 0) error("Division");
				left /= d;
				break;
			}

			case '%':
			{
				int d = primary();
				int i1 = int(left);

				if (i1 != left)
					error("Left operand % don`t int");

				int i2 = int(d);

				if (i2 != d)
					error("Right operand % don`t int");

				if (i2 == 0) error("%: division by zero");

				left = i1 % i2;
				break;
			}

			default:
				ts.putback(t);  // Помещаем объект t обратно в поток лексем

				return left;
		}
	}
}
//===============================================================================================================================
int expression()
{
	// Считывам и вычисляем Терм
	int left = term();

	while (true)
	{
		// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
			case '+':
			{ // Вычисляем и добавляем Терм
				left += term();
				break;
			}

			case '-':
			{
				// Вычисляем и вычитаем Терм
				left -= term();
				break;
			}

			default:
				ts.putback(t);  // Помещаем объект t обратно в поток лексем
				
				return left;
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
class Variable
{
public:
	std::string name;
	int value;

	Variable(std::string n, int v)
		:name(n), value(v)
	{
	}
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
int get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
			return var_table[i].value;

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, int d)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
		{
			var_table[i].value = d;
			return;
		}
	error("set: indefinite variable");
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == var)
			return true;
	return false;
}
//===============================================================================================================================
int Token_stream::define_name(std::string var, int val)
{
	if (is_declared(var))
		error("declared twice");

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
std::string Token_stream::statement()
{
	Token t = ts.get();
	int g;
	std::string result;
	switch (t.kind)
	{
		default:
			ts.putback(t);

			g = expression();
			result = convert_int_to_string(g);
			return result;
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception &e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or int and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception &e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}
//===============================================================================================================================
//	V 7. Разработайте вариант калькулятора из главы 7, который работал бы не с арабскими, а с римскими цифрами, например XXI+CIV==CXXV

