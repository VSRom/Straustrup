/*
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <gsl/gsl>

void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================
//===============================================================================================================================
class Variable
{
public:
	Variable();

	std::string name;
	double value;

	int isConst();

	Variable(std::string n, double v)
		:name(n), value(v)
	{
	}
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
int Variable::isConst()
{
	for (int i = 0; i < var_table.size(); ++i)
	(var_table[i].is_const == true)

		error("Cannot assign to const!");
}
//===============================================================================================================================
double get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)
	{
		if (var_table[i].name == s)
			return var_table[i].value;
	}

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, double d)
{
		for (int i = 0; i < var_table.size(); ++i)
			if (var_table[i].name == s)
			{
				var_table[i].value = d;
				return;
			}
}
//===============================================================================================================================
double expression();
double term();
double factorial(double left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	double value;
	std::string name;

	Token(double val)
		:value(val)
	{ }

	Token(char ch)
		:kind(ch), value(0.0)
	{ }

	Token(char ch, double val)
		:kind(ch), value(val)
	{ }

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{ }
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	double statement();
	double declaration();
	void calculate();
	bool is_declared(std::string var);
	double define_name(std::string var, double val);
	
private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{'\0'} // В буфере нет ни одного объекта
{ }
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const std::string useLet = "let";
const char let = '#';	// Лексема let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char uPow = 'p';	// Лексема sqrt
const std::string usePow = "pow";	// Ключевая функция sqrt
//===============================================================================================================================
const char quit = 'q';	// Лексему quit
const std::string useQuit = "quit";	// Ключевая функция quit
//===============================================================================================================================
const char number = '8';
const char print = ';';
const char underscore = '_';
const char grab = '=';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
	case ';': case 'quit': case '(': case ')': case '{': case '}': case 'sqrt': case 'pow': case 'let':
	case '+': case '-': case '*': case '/': case '!': case '%': case '=': case ',': case '#':
		return Token(ch); // пусть каждый символ представляет себя сам

	case '.': 
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	{
		std::cin.putback(ch); // возвращем цифру обратно в поток ввода

		double val;
		std::cin >> val; // считываем число с плавающей точкой
		return Token(number, val); // пусть символ '8' означает "число"
	}
	default:

		if (isalpha(ch))	// Является ли лексема введная буквой?
		{
			std::string s;
			s += ch;

			while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)) || ch == underscore)	// Считываем все следующие буквы или цифры
				s += ch;
			
			std::cin.putback(ch);

			// Проверяем какие буквы в нашей строке s
			// При совпадение со строками присваиваем значение символьное для использование в switch

			if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

			if (s == usePow) return Token(uPow);

			if (s == useQuit) return Token(quit);

			if (ch == let || s == useLet) return Token(let);
				return Token(name, s);
		}
		error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
	if (ch == c) return;
}
//===============================================================================================================================
double powpow(double value, int i);
//===============================================================================================================================
double primary()
{
	Token t = ts.get();

	double value;

	if (t.kind == number) 
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!') 
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
		case uPow:
		{
			t = ts.get();
		
			if (t.kind != '(')					error("pow it`s looks like pow( x(double),i(int) )");	// Является ли элемент после sqrt - '('
			
			t = ts.get();
			double x = t.value;
			
			t = ts.get();
			if (t.kind != ',')					error("pow it`s looks like pow( x(double),i(int) )");

			t = ts.get();
			int i = gsl::narrow<int>(t.value);

			double d = powpow(x, i);

			t = ts.get();	// Берем символ после уравнения
		
			if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
				error("pow it`s looks like pow( x(double),i(int) )");
		
			return d;	// Вернем pow в случае успеха в обоих случаях
		}
	case uSqrt:
	{
		t = ts.get();	// Получаем следующий элемент

		if (t.kind != '(')	// Является ли элемент после sqrt - '('
			error("sqrt it`s looks like sqrt(x)");

		double d = expression();	// Если является считаем внутри скобок уравнение

		if (d <= 0) error("sqrt cannot be negative");
		t = ts.get();	// Берем символ после уравнения

		if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
			error("please, don`t forget == ( ***** )");

		return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
	}

		case '(':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

	default:
		error("Primary Exprected!");
	}
}
//===============================================================================================================================
double powpow(double value, int i)
{
	double powpow = value;

	for (int j = 1; j < i; j++)
	{
		powpow *= value;
	}
	return powpow;
}
//===============================================================================================================================
double factorial(double value)
{
	int i;
	double fact = 1;

	if (value < 0) error("Factorial not may < 0");
	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;
	return value;
}
//===============================================================================================================================
double term()
{
	double left = primary();
	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {
		case '*':
		{
			left *= primary();
			break;
		}

		case '/':
		{
			double d = primary();
			if (d == 0) error("Division");
			left /= d;
			break;
		}

		case '%':
		{
			double d = primary();
			int i1 = int(left);
			if (i1 != left)
				error("Left operand % don`t int");

			int i2 = int(d);
			if (i2 != d)
				error("Right operand % don`t int");

			if (i2 == 0) error("%: division by zero");
			left = i1 % i2;
			break;
		}
		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;
		}
	}
}
//===============================================================================================================================
double expression()
{
	// Считывам и вычисляем Терм
	double left = term();

	while (true)
	{// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
		case '+':
		{ // Вычисляем и добавляем Терм
			left += term();
			break;
		}
		case '-':
		{
			// Вычисляем и вычитаем Терм
			left -= term();
			break;
		}
		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;    // Символов + и - нет, возвращаем ответ
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
		for (int i = 0; i < var_table.size(); ++i)

			if (var_table[i].name == var)
			{
					var_table.erase(var_table.begin() + i);
					return true;
			}

	return false;
}
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)
// Добавляем пару(var,val) в вектор var_table
{
		if (is_declared(var))

			std::cout << var << " == ReWrite! == " << val << '\n';

		var_table.push_back(Variable(var, val));
		return val;
}
//===============================================================================================================================
double Token_stream::declaration()

// Предполагается что мы можем выделить ключевое слово "let"
// Обработка: name = выражение
// Объявляется переменная с именем "name" с начальным значение, заданным "Выражением"
{
	Token t = ts.get();

	if (t.kind != name) error("In announcement waiting variable 'name'");

	std::string var_name = t.name;

	Token t2 = ts.get();

	if (t2.kind != '=') error("In announcement missed symbol = ");

	double d = expression();

	define_name(var_name, d);
	return d;
}
//===============================================================================================================================
double Token_stream::statement()
{
	Token t = ts.get();

	switch (t.kind)
	{
	case grab:
	{
		Token t = ts.get();
		if (t.kind == name)
			std::string var_name = t.name;

		Token next = ts.get();
		if (next.kind == grab)
		{

		}
		else
			return expression();
	}
	case let:
		return declaration();

	default:
		ts.putback(t);
		return expression();
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or double and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception& e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}


//===============================================================================================================================

//===============================================================================================================================
	3. Реализуйте именованные константы, которые действительно не могут изменять свои значения.
Подсказка: в класс Variable необходимо добавить функцию-член, различающую константы и переменные и проверяющую это при выполнении функции set_value().
Если хотите дать пользователю возможность объявлять собственные именованные константы (а не только pi и e),
то необходимо добавить соответствующее обозначение, например const pi = 3.14;.
//===============================================================================================================================

//===============================================================================================================================
	V	2. Реализуйте оператор присваивания =, чтобы можно было изменять значение переменной после ее объявления с помощью инструкции let.
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
		for (int i = 0; i < var_table.size(); ++i)

			if (var_table[i].name == var)
			{
					var_table.erase(var_table.begin() + i);
					return true;
			}

	return false;
}
//===============================================================================================================================
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)

// Добавляем пару(var,val) в вектор var_table
{
	if (is_declared(var))

		std::cout << var << " == ReWrite! == " << val << '\n';

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
	V	1. Предусмотрите использование символа подчеркивания в именах внутри программы–калькулятора.
//===============================================================================================================================
while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)) || ch == underscore)	// Считываем все следующие буквы или цифры
				s += ch;
//===============================================================================================================================
	7. Измените “ключевое слово выхода” с q на exit. Для этого понадобится строка для кодирования инструкции “выход”, как мы уже делали для инструкции “let” в разделе 7.8.2.
//===============================================================================================================================
#include <iostream>
#include <vector>
#include <string>
#include <cmath>

void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================
double expression();
double term();
double factorial(double left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	double value;
	std::string name;

	Token(double val)
		:value(val)
	{ }

	Token(char ch)
		:kind(ch), value(0.0)
	{ }

	Token(char ch, double val)
		:kind(ch), value(val)
	{ }

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{ }
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	double statement();
	double declaration();
	void calculate();
	bool is_declared(std::string var);
	double define_name(std::string var, double val);

private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{'\0'} // В буфере нет ни одного объекта
{ }
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const char let = '#';	// Лексема let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char uPow = 'p';	// Лексема sqrt
const std::string usePow = "pow";	// Ключевая функция sqrt
//===============================================================================================================================
const char quit = 'q';	// Лексему quit
const std::string useQuit = "quit";	// Ключевая функция quit
//===============================================================================================================================
const char number = '8';
const char print = ';';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
	case ';': case 'quit': case '(': case ')': case '{': case '}': case 'sqrt': case 'pow':
	case '+': case '-': case '*': case '/': case '!': case '%': case '=': case ',': case '#':
		return Token(ch); // пусть каждый символ представляет себя сам

	case '.':
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	{
		std::cin.putback(ch); // возвращем цифру обратно в поток ввода

		double val;
		std::cin >> val; // считываем число с плавающей точкой
		return Token(number, val); // пусть символ '8' означает "число"
	}
	default:

		if (isalpha(ch))	// Является ли лексема введная буквой?
		{
			std::string s;
			s += ch;

			while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)))	// Считываем все следующие буквы
				s += ch;

			std::cin.putback(ch);

			// Проверяем какие буквы в нашей строке s
			// При совпадение со строками присваиваем значение символьное для использование в switch

			if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

			if (s == usePow) return Token(uPow);

			if (s == useQuit) return Token(quit);

			if (ch == let) return Token(let);
				return Token(name, s);
		}
		error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
		if (ch == c) return;
}
//===============================================================================================================================
double get_value(std::string s);
double powpow(double value, int i);
//===============================================================================================================================
double primary()
{
	Token t = ts.get();

	double value;

	if (t.kind == number)
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!')
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
		case uPow:
		{
			t = ts.get();

			if (t.kind != '(')					error("pow it`s looks like pow( x(double),i(int) )");	// Является ли элемент после sqrt - '('

			t = ts.get();
			double x = t.value;

			t = ts.get();
			if (t.kind != ',')					error("pow it`s looks like pow( x(double),i(int) )");

			t = ts.get();
			int i = t.value;
			if (t.value != i)
			{
				error("The second number 'i' must be an integer)");
				return 0;
			}

			double d = powpow(x, i);

			t = ts.get();	// Берем символ после уравнения

			if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
				error("pow it`s looks like pow( x(double),i(int) )");

			return d;	// Вернем pow в случае успеха в обоих случаях
		}
	case uSqrt:
	{
		t = ts.get();	// Получаем следующий элемент

		if (t.kind != '(')	// Является ли элемент после sqrt - '('
			error("sqrt it`s looks like sqrt(x)");

		double d = expression();	// Если является считаем внутри скобок уравнение

		if (d <= 0) error("sqrt cannot be negative");
		t = ts.get();	// Берем символ после уравнения

		if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
			error("please, don`t forget == ( ***** )");

		return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
	}

		case '(':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

	default:
		error("Primary Exprected!");
	}
}
//===============================================================================================================================
double powpow(double value, int i)
{
	double powpow = value;

	for (int j = 1; j < i; j++)
	{
		powpow *= value;
	}
	return powpow;
}
//===============================================================================================================================
double factorial(double value)
{
	int i;
	double fact = 1;

	if (value < 0) error("Factorial not may < 0");
	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;
	return value;
}
//===============================================================================================================================
double term()
{
	double left = primary();

	// Получаем следующую лексему из потока лексем


	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {

		case '*':
		{
			left *= primary();
			break;
		}

		case '/':
		{
			double d = primary();
			if (d == 0) error("Division");
			left /= d;
			break;
		}

		case '%':
		{
			double d = primary();
			int i1 = int(left);
			if (i1 != left)
				error("Left operand % don`t int");

			int i2 = int(d);
			if (i2 != d)
				error("Right operand % don`t int");

			if (i2 == 0) error("%: division by zero");
			left = i1 % i2;
			break;
		}
		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;
		}
	}
}
//===============================================================================================================================
double expression()
{
	// Считывам и вычисляем Терм
	double left = term();

	while (true)
	{// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
		case '+':
		{ // Вычисляем и добавляем Терм
			left += term();
			break;
		}
		case '-':
		{
			// Вычисляем и вычитаем Терм
			left -= term();
			break;
		}
		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;    // Символов + и - нет, возвращаем ответ
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
class Variable
{
public:
	std::string name;
	double value;

	Variable(std::string n, double v)
		:name(n), value(v)
	{ }
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
double get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
			return var_table[i].value;

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, double d)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
		{
			var_table[i].value = d;
			return;
		}
	error("set: indefinite variable");
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == var)
			return true;
	return false;
}
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)

// Добавляем пару(var,val) в вектор var_table
{
	if (is_declared(var))
		error("declared twice");

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
double Token_stream::declaration()

// Предполагается что мы можем выделить ключевое слово "let"
// Обработка: name = выражение
// Объявляется переменная с именем "name" с начальным значение, заданным "Выражением"
{
	Token t = ts.get();

	if (t.kind != name) error("In announcement waiting variable 'name'");

	std::string var_name = t.name;

	Token t2 = ts.get();

	if (t2.kind != '=') error("In announcement missed symbol =");

	double d = expression();
	define_name(var_name, d);
	return d;
}
//===============================================================================================================================
double Token_stream::statement()
{
	Token t = ts.get();

	switch (t.kind)
	{
	case let:
		return declaration();

	default:
		ts.putback(t);
		return expression();
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or double and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception& e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}

//===============================================================================================================================
	V	6. Измените “ключевое слово объявления” с let на #.
//===============================================================================================================================
#include <iostream>
#include <vector>
#include <string>
#include <cmath>

void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================

//===============================================================================================================================
double expression();
double term();
double factorial(double left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	double value;
	std::string name;

	Token(double val)
		:value(val)
	{ }

	Token(char ch)
		:kind(ch), value(0.0)
	{ }

	Token(char ch, double val)
		:kind(ch), value(val)
	{ }

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{ }
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	double statement();
	double declaration();
	void calculate();
	bool is_declared(std::string var);
	double define_name(std::string var, double val);

private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{'\0'} // В буфере нет ни одного объекта
{ }
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const char let = '#';	// Лексема let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char uPow = 'p';	// Лексема sqrt
const std::string usePow = "pow";	// Ключевая функция sqrt
//===============================================================================================================================
const char number = '8';
const char quit = 'q';
const char print = ';';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
	case ';': case 'q': case '(': case ')': case '{': case '}': case 'sqrt': case 'pow':
	case '+': case '-': case '*': case '/': case '!': case '%': case '=': case ',': case '#':
		return Token(ch); // пусть каждый символ представляет себя сам

	case '.':
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	{
		std::cin.putback(ch); // возвращем цифру обратно в поток ввода

		double val;
		std::cin >> val; // считываем число с плавающей точкой
		return Token(number, val); // пусть символ '8' означает "число"
	}
	default:

		if (isalpha(ch))	// Является ли лексема введная буквой?
		{
			std::string s;
			s += ch;

			while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)))	// Считываем все следующие буквы
				s += ch;

			std::cin.putback(ch);

			// Проверяем какие буквы в нашей строке s
			// При совпадение со строками присваиваем значение символьное для использование в switch

			if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

			if (s == usePow) return Token(uPow);

			if (ch == let) return Token(let);
				return Token(name, s);
		}
		error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
		if (ch == c) return;
}
//===============================================================================================================================
double get_value(std::string s);
double powpow(double value, int i);
//===============================================================================================================================
double primary()
{
	Token t = ts.get();

	double value;

	if (t.kind == number)
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!')
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
		case uPow:
		{
			t = ts.get();

			if (t.kind != '(')					error("pow it`s looks like pow( x(double),i(int) )");	// Является ли элемент после sqrt - '('

			t = ts.get();
			double x = t.value;

			t = ts.get();
			if (t.kind != ',')					error("pow it`s looks like pow( x(double),i(int) )");

			t = ts.get();
			int i = t.value;
			if (t.value != i)
			{
				error("The second number 'i' must be an integer)");
				return 0;
			}

			double d = powpow(x, i);

			t = ts.get();	// Берем символ после уравнения

			if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
				error("pow it`s looks like pow( x(double),i(int) )");

			return d;	// Вернем pow в случае успеха в обоих случаях
		}
	case uSqrt:
	{
		t = ts.get();	// Получаем следующий элемент

		if (t.kind != '(')	// Является ли элемент после sqrt - '('
			error("sqrt it`s looks like sqrt(x)");

		double d = expression();	// Если является считаем внутри скобок уравнение

		if (d <= 0) error("sqrt cannot be negative");
		t = ts.get();	// Берем символ после уравнения

		if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
			error("please, don`t forget == ( ***** )");

		return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
	}

		case '(':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

	default:
		error("Primary Exprected!");
	}
}
//===============================================================================================================================
double powpow(double value, int i)
{
	double powpow = value;

	for (int j = 1; j < i; j++)
	{
		powpow *= value;
	}
	return powpow;
}
//===============================================================================================================================
double factorial(double value)
{
	int i;
	double fact = 1;

	if (value < 0) error("Factorial not may < 0");

	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;

	return value;
}
//===============================================================================================================================
double term()
{
	double left = primary();

	// Получаем следующую лексему из потока лексем


	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {

		case '*':
		{
			left *= primary();
			//t = ts.get();
			break;
		}

		case '/':
		{
			double d = primary();
			if (d == 0) error("Division");
			left /= d;
			//t = ts.get();
			break;
		}

		case '%':
		{
			double d = primary();
			int i1 = int(left);

			if (i1 != left)
				error("Left operand % don`t int");

			int i2 = int(d);

			if (i2 != d)
				error("Right operand % don`t int");

			if (i2 == 0) error("%: division by zero");

			left = i1 % i2;
			//t = ts.get();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем

			return left;
		}
	}
}
//===============================================================================================================================
double expression()
{
	// Считывам и вычисляем Терм
	double left = term();

	while (true)
	{
		// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
		case '+':
		{ // Вычисляем и добавляем Терм
			left += term();
			break;
		}

		case '-':
		{
			// Вычисляем и вычитаем Терм
			left -= term();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;    // Символов + и - нет, возвращаем ответ
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
class Variable
{
public:
	std::string name;
	double value;

	Variable(std::string n, double v)
		:name(n), value(v)
	{ }
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
double get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
			return var_table[i].value;

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, double d)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
		{
			var_table[i].value = d;
			return;
		}
	error("set: indefinite variable");
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == var)
			return true;
	return false;
}
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)

// Добавляем пару(var,val) в вектор var_table
{
	if (is_declared(var))
		error("declared twice");

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
double Token_stream::declaration()

// Предполагается что мы можем выделить ключевое слово "let"
// Обработка: name = выражение
// Объявляется переменная с именем "name" с начальным значение, заданным "Выражением"
{
	Token t = ts.get();

	if (t.kind != name) error("In announcement waiting variable 'name'");

	std::string var_name = t.name;

	Token t2 = ts.get();

	if (t2.kind != '=') error("In announcement missed symbol =");

	double d = expression();
	define_name(var_name, d);
	return d;
}
//===============================================================================================================================
double Token_stream::statement()
{
	Token t = ts.get();

	switch (t.kind)
	{
	case let:
		return declaration();

	default:
		ts.putback(t);
		return expression();
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or double and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception& e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}

//===============================================================================================================================
	V	5. Предусмотрите возможность использовать функцию pow(x,i), означающую “умножить x на себя i раз”; например pow(2.5,3) равно 2.5*2.5*2.5.
Аргумент i должен быть целым числом. Проверьте это с помощью оператора %.
//===============================================================================================================================
#include <iostream>
#include <vector>
#include <string>
#include <cmath>

void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================

//===============================================================================================================================
double expression();
double term();
double factorial(double left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	double value;
	std::string name;

	Token(double val)
		:value(val)
	{ }

	Token(char ch)
		:kind(ch), value(0.0)
	{ }

	Token(char ch, double val)
		:kind(ch), value(val)
	{ }

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{ }
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	double statement();
	double declaration();
	void calculate();
	bool is_declared(std::string var);
	double define_name(std::string var, double val);

private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{'\0'} // В буфере нет ни одного объекта
{ }
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const char let = 'l';	// Лексема let
const std::string declkey = "let";	// Ключевое слово let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char uPow = 'p';	// Лексема sqrt
const std::string usePow = "pow";	// Ключевая функция sqrt
//===============================================================================================================================
const char number = '8';
const char quit = 'q';
const char print = ';';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
	case ';': case 'q': case '(': case ')': case '{': case '}': case 'sqrt': case 'pow':
	case '+': case '-': case '*': case '/': case '!': case '%': case '=': case ',':
		return Token(ch); // пусть каждый символ представляет себя сам

	case '.':
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	{
		std::cin.putback(ch); // возвращем цифру обратно в поток ввода

		double val;
		std::cin >> val; // считываем число с плавающей точкой
		return Token(number, val); // пусть символ '8' означает "число"
	}
	default:

		if (isalpha(ch))	// Является ли лексема введная буквой?
		{
			std::string s;
			s += ch;

			while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)))	// Считываем все следующие буквы
				s += ch;

			std::cin.putback(ch);

			// Проверяем какие буквы в нашей строке s
			// При совпадение со строками присваиваем значение символьное для использование в switch

			if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

			if (s == usePow) return Token(uPow);

			else if (s == declkey) return Token(let);	// Ключевое слово let
			return Token(name, s);

		}
		error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
		if (ch == c) return;
}
//===============================================================================================================================
double get_value(std::string s);
double powpow(double value, int i);
//===============================================================================================================================
double primary()
{
	Token t = ts.get();

	double value;

	if (t.kind == number)
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!')
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
		case uPow:
		{
			t = ts.get();

			if (t.kind != '(')					error("pow it`s looks like pow( x(double),i(int) )");	// Является ли элемент после sqrt - '('

			t = ts.get();
			double x = t.value;

			t = ts.get();
			if (t.kind != ',')					error("pow it`s looks like pow( x(double),i(int) )");

			t = ts.get();
			int i = t.value;
			if (t.value != i)
			{
				error("The second number 'i' must be an integer)");
				return 0;
			}

			double d = powpow(x, i);

			t = ts.get();	// Берем символ после уравнения

			if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
				error("pow it`s looks like pow( x(double),i(int) )");

			return d;	// Вернем pow в случае успеха в обоих случаях
		}
	case uSqrt:
	{
		t = ts.get();	// Получаем следующий элемент

		if (t.kind != '(')	// Является ли элемент после sqrt - '('
			error("sqrt it`s looks like sqrt(x)");

		double d = expression();	// Если является считаем внутри скобок уравнение

		if (d <= 0) error("sqrt cannot be negative");
		t = ts.get();	// Берем символ после уравнения

		if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
			error("please, don`t forget == ( ***** )");

		return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
	}

		case '(':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

	default:
		error("Primary Exprected!");
	}
}
//===============================================================================================================================
double powpow(double value, int i)
{
	double powpow = value;

	for (int j = 1; j < i; j++)
	{
		powpow *= value;
	}
	return powpow;
}
//===============================================================================================================================
double factorial(double value)
{
	int i;
	double fact = 1;

	if (value < 0) error("Factorial not may < 0");

	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;

	return value;
}
//===============================================================================================================================
double term()
{
	double left = primary();

	// Получаем следующую лексему из потока лексем


	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {

		case '*':
		{
			left *= primary();
			//t = ts.get();
			break;
		}

		case '/':
		{
			double d = primary();
			if (d == 0) error("Division");
			left /= d;
			//t = ts.get();
			break;
		}

		case '%':
		{
			double d = primary();
			int i1 = int(left);

			if (i1 != left)
				error("Left operand % don`t int");

			int i2 = int(d);

			if (i2 != d)
				error("Right operand % don`t int");

			if (i2 == 0) error("%: division by zero");

			left = i1 % i2;
			//t = ts.get();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем

			return left;
		}
	}
}
//===============================================================================================================================
double expression()
{
	// Считывам и вычисляем Терм
	double left = term();

	while (true)
	{
		// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
		case '+':
		{ // Вычисляем и добавляем Терм
			left += term();
			break;
		}

		case '-':
		{
			// Вычисляем и вычитаем Терм
			left -= term();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;    // Символов + и - нет, возвращаем ответ
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
class Variable
{
public:
	std::string name;
	double value;

	Variable(std::string n, double v)
		:name(n), value(v)
	{ }
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
double get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
			return var_table[i].value;

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, double d)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
		{
			var_table[i].value = d;
			return;
		}
	error("set: indefinite variable");
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == var)
			return true;
	return false;
}
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)

// Добавляем пару(var,val) в вектор var_table
{
	if (is_declared(var))
		error("declared twice");

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
double Token_stream::declaration()

// Предполагается что мы можем выделить ключевое слово "let"
// Обработка: name = выражение
// Объявляется переменная с именем "name" с начальным значение, заданным "Выражением"
{
	Token t = ts.get();

	if (t.kind != name) error("In announcement waiting variable 'name'");

	std::string var_name = t.name;

	Token t2 = ts.get();

	if (t2.kind != '=') error("In announcement missed symbol =");

	double d = expression();
	define_name(var_name, d);
	return d;
}
//===============================================================================================================================
double Token_stream::statement()
{
	Token t = ts.get();

	switch (t.kind)
	{
	//		case uSqrt:
	//		return use_sqrt();

	case let:
		return declaration();

	default:
		ts.putback(t);
		return expression();
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or double and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception& e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}
}
//===============================================================================================================================
	V	4. Предусмотрите перехват попыток извлечь квадратный корень из отрицательного числа и выведите на экран соответствующее сообщение об ошибке.
//===============================================================================================================================
	V	1. Проведите тестирование и исправьте все ошибки, которые пропустили при комментировании.
	V	2. Добавьте предопределенное имя k со значением 1000.
	V	3. Предусмотрите возможность вычисления функции sqrt(), например sqrt(2 + 6.7).Естественно, значение sqrt(x) — это квадратный корень из числа x; например sqrt(9) равно 3.
//===============================================================================================================================
#include <iostream>
#include <vector>
#include <string>
#include <cmath>

void error(std::string s)
{
	std::cerr << s << '\n';
}
//===============================================================================================================================

//===============================================================================================================================
double expression();
double term();
double factorial(double left);
//===============================================================================================================================
class Token
{
public:
	char kind;
	double value;
	std::string name;

	Token(double val)
		:value(val)
	{ }

	Token(char ch)
		:kind(ch), value(0.0)
	{ }

	Token(char ch, double val)
		:kind(ch), value(val)
	{ }

	Token(char ch, std::string n)
		:kind(ch), name(n)
	{ }
};
//===============================================================================================================================
class Token_stream
{
public: // Пользовательский интерфейс
	Token_stream();	// Создаём объект класса Token_stream считывающий данные из потока cin

	Token get();	// Cчитывает лексему

	void putback(Token t);	// Возвращает лексему
	void ignore(char c);	// Отбрасывает символы, предшуствующие символу с включительно
	double statement();
	double declaration();
	void calculate();
	bool is_declared(std::string var);
	double define_name(std::string var, double val);

//	const char name = 'a';	// Лексему name
//	static constexpr char let = 'L';	// Лексема let
//	const std::string declkey = "let";	// Ключевое слово let

private: // Детали реализации
	bool full;	// Есть лексему в буфере?
	Token buffer;	// Здесь хранится объект класса Token возвращаем в поток функцией putback()
};
//===============================================================================================================================
Token_stream::Token_stream()
	:full(false), buffer{'\0'} // В буфере нет ни одного объекта
{ }
//===============================================================================================================================
Token_stream ts;
//===============================================================================================================================
const char name = 'a';	// Лексему name
//===============================================================================================================================
const char let = 'l';	// Лексема let
const std::string declkey = "let";	// Ключевое слово let
//===============================================================================================================================
const char uSqrt = 's';	// Лексема sqrt
const std::string useSqrt = "sqrt";	// Ключевая функция sqrt
//===============================================================================================================================
const char number = '8';
const char quit = 'q';
const char print = ';';
//===============================================================================================================================
Token Token_stream::get()
{
	// Считываем символ из потока cin и образуем лексему
	if (full)	// Проверяем, есть ли в потоке хотя бы одна лексема
	{
		full = false;
		return buffer;
	}
	char ch;
	std::cin >> ch;

	switch (ch)
	{
	case ';': case 'q': case '(': case ')': case '{': case '}': case 'sqrt':
	case '+': case '-': case '*': case '/': case '!': case '%': case '=':
		return Token(ch); // пусть каждый символ представляет себя сам

	case '.':
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	{
		std::cin.putback(ch); // возвращем цифру обратно в поток ввода

		double val;
		std::cin >> val; // считываем число с плавающей точкой
		return Token(number, val); // пусть символ '8' означает "число"
	}
	default:

		if (isalpha(ch))	// Является ли лексема введная буквой?
		{
			std::string s;
			s += ch;

			while (std::cin.get(ch) && (isalpha(ch) || isdigit(ch)))	// Считываем все следующие буквы
				s += ch;

			std::cin.putback(ch);

			// Проверяем какие буквы в нашей строке s
			// При совпадение со строками присваиваем значение символьное для использование в switch

			if (s == useSqrt) return Token(uSqrt);	// Ключевое слово sqrt

			else if (s == declkey) return Token(let);	// Ключевое слово let
			return Token(name, s);

		}
		error("Error Bad Token!");

	}
}
//===============================================================================================================================
void Token_stream::putback(Token t)
{
	if (full == false)
	{
		buffer = t;     // Копируем объект t в буфер
		full = true;    // Теперь буфер полон
	}
}
//===============================================================================================================================
void Token_stream::ignore(char c)
{
	if (full && buffer.kind == c)
	{
		full = false;
		return;
	}

	full = false;

	char ch = 0;
	while (std::cin >> ch)
		if (ch == c) return;
}
//===============================================================================================================================
double get_value(std::string s);
//===============================================================================================================================
double primary()
{
	Token t = ts.get();

	double value;

	if (t.kind == number)
	{
		Token next_token = ts.get();    //Берем следующий символ после цифры
		value = t.value;

		if (next_token.kind == '!')
			return factorial(value);    // Если следующий символ ! то выполняем подсчет факториала и возвращаем его значение
		else
		{
			ts.putback(next_token); // Иначе вернем это значение оператор или операнд обратно во входной поток для дальнейшей обработки
			return value;
		}
	}

	switch (t.kind)
	{
	case uSqrt:
	{
		t = ts.get();	// Получаем следующий элемент

		if (t.kind != '(')	// Является ли элемент после sqrt - '('
			error("sqrt it`s looks like sqrt(x)");

		double d = expression();	// Если является считаем внутри скобок уравнение

		if (d <= 0) error("sqrt cannot be negative");
		t = ts.get();	// Берем символ после уравнения

		if (t.kind != ')')	// Проверяем является ли символ после уравнения закрывающейся скобкой
			error("please, don`t forget == ( ***** )");

		return sqrt(d);	// Вернем корень в случае успеха в обоих случаях
	}

		case '(':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != ')')
				error("please, don`t forget == ( ***** )");

			return d;
		}

		case '{':
		{
			double d = expression();
			t = ts.get();

			if (t.kind != '}')
				error("please, don`t forget == { ( ***** ) }");

			return d;
		}

		case '-':
			return -primary();

		case number:
			return t.value;

		case name:
			return get_value(t.name);

		case '=':
			return t.value;	// Возвращаем число

	default:
		error("Primary Exprected!");
	}
}
//===============================================================================================================================
double factorial(double value)
{
	int i;
	double fact = 1;

	if (value < 0) error("Factorial not may < 0");

	if (value == 0) fact = 1;

	for (i = 1; i <= value; i++)
	{
		fact *= i;
	}

	value = fact;

	return value;
}
//===============================================================================================================================
double term()
{
	double left = primary();

	// Получаем следующую лексему из потока лексем


	while (true)
	{
		Token t = ts.get();

		switch (t.kind) {

		case '*':
		{
			left *= primary();
			//t = ts.get();
			break;
		}

		case '/':
		{
			double d = primary();
			if (d == 0) error("Division");
			left /= d;
			//t = ts.get();
			break;
		}

		case '%':
		{
			double d = primary();
			int i1 = int(left);

			if (i1 != left)
				error("Left operand % don`t int");

			int i2 = int(d);

			if (i2 != d)
				error("Right operand % don`t int");

			if (i2 == 0) error("%: division by zero");

			left = i1 % i2;
			//t = ts.get();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем

			return left;
		}
	}
}
//===============================================================================================================================
double expression()
{
	// Считывам и вычисляем Терм
	double left = term();

	while (true)
	{
		// Получаем следующую лексему из потока лексем
		Token t = ts.get();

		switch (t.kind)
		{
		case '+':
		{ // Вычисляем и добавляем Терм
			left += term();
			break;
		}

		case '-':
		{
			// Вычисляем и вычитаем Терм
			left -= term();
			break;
		}

		default:
			ts.putback(t);  // Помещаем объект t обратно в поток лексем
			return left;    // Символов + и - нет, возвращаем ответ
		}
	}
}
//===============================================================================================================================
void clean_up_mess()
{
	ts.ignore(print);
}
//===============================================================================================================================
class Variable
{
public:
	std::string name;
	double value;

	Variable(std::string n, double v)
		:name(n), value(v)
	{ }
};
//===============================================================================================================================
std::vector<Variable> var_table;
//===============================================================================================================================
double get_value(std::string s)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
			return var_table[i].value;

	error("get: indefinite lexeme");
}
//===============================================================================================================================
void set_value(std::string s, double d)
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == s)
		{
			var_table[i].value = d;
			return;
		}
	error("set: indefinite variable");
}
//===============================================================================================================================
bool Token_stream::is_declared(std::string var)

// Есть ли переменная var в векторе var_table?
{
	for (int i = 0; i < var_table.size(); ++i)

		if (var_table[i].name == var)
			return true;
	return false;
}
//===============================================================================================================================
double Token_stream::define_name(std::string var, double val)

// Добавляем пару(var,val) в вектор var_table
{
	if (is_declared(var))
		error("declared twice");

	var_table.push_back(Variable(var, val));
	return val;
}
//===============================================================================================================================
double Token_stream::declaration()

// Предполагается что мы можем выделить ключевое слово "let"
// Обработка: name = выражение
// Объявляется переменная с именем "name" с начальным значение, заданным "Выражением"
{
	Token t = ts.get();

	if (t.kind != name) error("In announcement waiting variable 'name'");

	std::string var_name = t.name;

	Token t2 = ts.get();

	if (t2.kind != '=') error("In announcement missed symbol =");

	double d = expression();
	define_name(var_name, d);
	return d;
}
//===============================================================================================================================
double Token_stream::statement()
{
	Token t = ts.get();

	switch (t.kind)
	{
	//		case uSqrt:
	//		return use_sqrt();

	case let:
		return declaration();

	default:
		ts.putback(t);
		return expression();
	}
}
//===============================================================================================================================
void Token_stream::calculate()
{
	const std::string promt = "> ";
	const std::string result = "= ";

	while (std::cin)try
	{
		std::cout << promt;	// Получили >
		Token t = ts.get();	// Считываем ввод

		while (t.kind == print)	t = ts.get();	// Сначала игнорируем все инструкции "печать"

		if (t.kind == quit)
			return;

		ts.putback(t);
		std::cout << result << statement() << '\n';
	}
	catch (std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		clean_up_mess();
	}
}
//===============================================================================================================================
int main()try
{
	const std::string HELLO = "Hello, my Dear Friend! Welcome to the calculator!!!\nYou may enter numbers int or double and symbols:\n- + * / { ( ) }for math formuls!\nq  Quit!\n=  Total\nLET`S GO! GOOD NICE!!!\n";
	std::cout << HELLO;

	ts.define_name("pi", 3.141592535);	// Заносим pi и e в определение калькулятора до запуска
	ts.define_name("e", 2.7182818284);
	ts.define_name("k", 1000);

	ts.calculate();
}
catch (std::exception& e) {
	std::cerr << e.what() << std::endl;
	return 1;
}
catch (...) {
	std::cerr << "exception \n";
	return 2;
}
//===============================================================================================================================
*/
